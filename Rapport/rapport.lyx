#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{listings}
\lstset{language=Python}
\end_preamble
\use_default_options true
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Simulation de quadricoptère avec Blender"
\pdf_author "Benoît Saccomano & Michael Muré"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3cm
\rightmargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Simulation de quadricoptère avec Blender
\end_layout

\begin_layout Author
Benoît Saccomano & Michael Muré
\end_layout

\begin_layout Date
13/05/2011
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Section
Modelisation
\end_layout

\begin_layout Standard
Nous avons modelisé le quadricoptère grâce à Blender.
 Comme le modèle est symetrique, nous avons utilisé le modifier 
\begin_inset Quotes eld
\end_inset

mirror
\begin_inset Quotes erd
\end_inset

, qui permet de ne modeliser qu'une moitié du modèle.
 La modelisation à été faite à partir d'une photo vue de dessus, trouvé
 dans un moteur de recherche.
 Nous avons mis cette photo en image de fond dans Blender, et modelisé par
 dessus pour avoir les bonne proportions.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename modifier.png
	scale 50
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Le modèle final complet (les deux cotés) comporte 652 points (vertices),
 et 668 faces, ce qui est assez leger pour un affichage en temps réel.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tex_modele.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Nous avons ensuite déplié en 2D, c'est à dire que pour chaques points du
 modèle est associé une coordonnée en 2D dans l'espace de la texture.
 Ces coordonnées s'appellent les coordonnées UV.
 Pour faire cela, le principe est de marquer certaines arrêtes (edge) du
 maillage comme etant des coutures (seam).
 Ces coutures sont visible en rouge sur la capture d'écran suivante.
 Le dépliage se fait ensuite grâce à un algorithme interne de Blender, qui
 va déplier (unwrap) au mieux ces surfaces.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename couture.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Une fois le dépliage terminé, nous avons texturé le modèle.
 Ce texturage s'est fait en 3 étapes.
\end_layout

\begin_layout Enumerate
Nou avons projeté la photo vue de dessus du modèle réel sur le modèle virtuel
 grâce à Blender.
 Cela nous a permis d'obtenir les décorations du dessus du modèle facilement,
 déformé de la bonne façon pour coller à notre dépliage.
\end_layout

\begin_layout Enumerate
Nous avons ensuite completé la texture grâce au logiciel de traitement d'image
 The Gimp.
 Nous avons utilisé notamment l'outil de clonage pour dupliquer la texture
 de polystirène noir partout où c'était necessaire.
\end_layout

\begin_layout Enumerate
Nous avons calculé l'ombrage que le modèle se fait sur lui même (ambient
 occlusion).
 C'est à dire que certaines partie du modèle en cache d'autre, ce qui crée
 des zones plus sombre que les autres.
 Blender permet de projeter sur une texture ces zones d'ombre, que nous
 avons ensuite combiné au reste de la texture.
 Celà permet d'avoir un peu plus de réalisme, pour un coût complètement
 nul au rendu.
\end_layout

\begin_layout Standard
La capture d'écran suivante présente la texture finale avec les différentes
 couches, ainsi que le dépliage du modèle.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tex_UV.png
	width 100text%

\end_inset


\end_layout

\begin_layout Section
Contenu de la scène
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename scene.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
La scène finale comporte plusieurs objets:
\end_layout

\begin_layout Itemize
Le modèle du quadricoptère (Quadri)
\end_layout

\begin_layout Itemize
Un niveau basique où évolue le modèle (Level)
\end_layout

\begin_layout Itemize
Une camera
\end_layout

\begin_layout Itemize
Un ensemble d'objets parenté à la camera qui servent à afficher le HUD,
 que nous détaillerons plus loin.
\end_layout

\begin_layout Itemize
Un modèle haute résolution du quadricoptère (Quadri.high), qui n'est pas
 utilisé actuellement.
\end_layout

\begin_layout Itemize
Un modèle ultra-simplifié du quadricoptère (32 points, 30 faces), qui va
 être utilisé comme modèle de collision pour le moteur physique (non actif
 actuellement).
\end_layout

\begin_layout Section
Simulation physique du quadricopère
\end_layout

\begin_layout Subsection
Principe global
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename logic_quadri.png
	width 100text%

\end_inset


\end_layout

\begin_layout Subsection
Comportement simple
\end_layout

\begin_layout Subsection
Comportement évolué
\end_layout

\begin_layout Subsection
Joystick
\end_layout

\begin_layout Subsubsection
Zone morte
\end_layout

\begin_layout Subsubsection
Gestion du pilotage
\end_layout

\begin_layout Section
HUD
\end_layout

\begin_layout Subsection
Principe global
\end_layout

\begin_layout Standard
Le HUD (head's up display) que nous avons implémenté est constitué d'un
 indicateur de vitesse et d'un indicateur d'altitude.
 Le principe est relativement simple.
 Pour chaque indicateur, deux plans sont positionné parallèlement à la camera
 et parenté à elle de sorte que si la caméra bouge, les indicateurs suivent.
 Ces plans sont texturés avec les deux textures suivantes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/michael/Bureau/projet quadricoptère/HUD/fondaltimetre.png
	lyxscale 50
	scale 50
	rotateOrigin center

\end_inset

 
\begin_inset Graphics
	filename /home/michael/Bureau/projet quadricoptère/HUD/aiguille.png
	lyxscale 50
	scale 50
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Les matériaux pour ces deux plans sont un peu particuliers:
\end_layout

\begin_layout Itemize
Activation de la transparence (la texture affecte les canaux color et alpha,
 valeur de alpha par défaut: 0).
\end_layout

\begin_layout Itemize
Matériau en shadeless, c'est à dire pas de calcul d'ombrage ou d'eclairage.
 Seule les couleurs de la texture sont affichés.
\end_layout

\begin_layout Standard
Le centre de l'objet aiguille est placé au niveau de l'axe de rotation de
 l'aiguille, de sorte qu'on ai juste à appliquer une rotation à l'aiguille
 pour fixer la valeur.
 Les afficheurs prennent vie grace à un script python simple que nous allons
 voir dans la partie suivante.
 Le réseau logique utilisé est le suivant:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename logic_HUD.png
	width 100col%
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Nous avons donc:
\end_layout

\begin_layout Itemize
Un sensor 
\begin_inset Quotes eld
\end_inset

Always
\begin_inset Quotes erd
\end_inset

 qui active le script à interval réguliers
\end_layout

\begin_layout Itemize
Un controller 
\begin_inset Quotes eld
\end_inset

Python
\begin_inset Quotes erd
\end_inset

 avec notre script
\end_layout

\begin_layout Itemize
Un actuator 
\begin_inset Quotes eld
\end_inset

Motion
\begin_inset Quotes erd
\end_inset

 qui ne sert strictement à rien, si ce n'est d'avoir un graph valide (sinon
 le script ne se déclencherai pas).
\end_layout

\begin_layout Subsection
Script python
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Python,numbers=left"
inline false
status open

\begin_layout Plain Layout

import bge 
\end_layout

\begin_layout Plain Layout

from mathutils import Matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# récupère la scène et la liste des objets
\end_layout

\begin_layout Plain Layout

scene = bge.logic.getCurrentScene()
\end_layout

\begin_layout Plain Layout

List = scene.objects
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# récupère le controleur, puis l'objet aiguille qui détient ce controleur
\end_layout

\begin_layout Plain Layout

cont = bge.logic.getCurrentController()
\end_layout

\begin_layout Plain Layout

aiguille = cont.owner
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# récupère l'objet quadricoptère dans la liste des objets de la scène, puis
 sa vitesse
\end_layout

\begin_layout Plain Layout

value = List['Quadri'].worldLinearVelocity.length
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# affecte une matrice de rotation à l'objet aiguille, calculée d'après la
 valeur à afficher
\end_layout

\begin_layout Plain Layout

aiguille.localOrientation = Matrix.Rotation(-value / 10.0, 4, 'Z').to_3x3()
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\end_body
\end_document
