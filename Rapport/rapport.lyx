#LyX 1.6.5 created this file. For more info see http://www.lyx.org/
\lyxformat 345
\begin_document
\begin_header
\textclass article
\begin_preamble
\usepackage{listings}
\lstset{language=Python}
\end_preamble
\use_default_options true
\language french
\inputencoding auto
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Simulation de quadricoptère avec Blender"
\pdf_author "Benoît Saccomano & Michael Muré"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize a4paper
\use_geometry true
\use_amsmath 1
\use_esint 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\leftmargin 3cm
\rightmargin 3cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\author "" 
\author "" 
\end_header

\begin_body

\begin_layout Title
Simulation de quadricoptère avec Blender
\end_layout

\begin_layout Author
Benoît Saccomano & Michael Muré
\end_layout

\begin_layout Date
13/05/2011
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Dans le cadre de notre projet nous avons été amené à modéliser en 3D un
 quadricoptère sous Blender.
 Ce document a pour but d'expliciter les différentes étapes que nous avons
 suivis afin de réaliser ce travail.
 
\end_layout

\begin_layout Standard
Dans un premier temps on reviendra sur la modélisation (au sens graphique)
 du modèle.
 Ensuite on décrira la méthode suivie afin d'intégrer à ce modèle un comportemen
t physique 
\begin_inset Quotes eld
\end_inset

primitif
\begin_inset Quotes erd
\end_inset

, c'est à dire qui agit basiquement sur les 4 moteurs.
 
\end_layout

\begin_layout Standard
On reviendra enfin sur les différentes extensions que nous avons ajoutés,
 à savoir un comportement plus évolué, la possibilité de controler le quadricopt
 ère à l'aide d'un Joystick ainsi qu'un HUD.
\end_layout

\begin_layout Standard
Quelques petites précisions supplémentaires avant de commencer : nous avons
 utilisé la version 2.57 de Blender, le design du modèle que nous avons pris
 est celui du ArDrone de Parrot, quant à la modélisation physique elle est
 apportée dans le Blender Game via des scripts (en Python) écrits par nos
 soins.
\end_layout

\begin_layout Section
Modelisation
\end_layout

\begin_layout Standard
Nous avons modelisé le quadricoptère grâce à Blender.
 Comme le modèle est symetrique, nous avons utilisé le modifier 
\begin_inset Quotes eld
\end_inset

mirror
\begin_inset Quotes erd
\end_inset

, qui permet de ne modeliser qu'une moitié du modèle.
 La modelisation à été faite à partir d'une photo vue de dessus, trouvé
 dans un moteur de recherche.
 Nous avons mis cette photo en image de fond dans Blender, et modelisé par
 dessus pour avoir les bonne proportions.
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename modifier.png
	scale 50
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Le modèle final complet (les deux cotés) comporte 652 points (vertices),
 et 668 faces, ce qui est assez leger pour un affichage en temps réel.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tex_modele.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Nous avons ensuite déplié en 2D, c'est à dire que pour chaques points du
 modèle est associé une coordonnée en 2D dans l'espace de la texture.
 Ces coordonnées s'appellent les coordonnées UV.
 Pour faire cela, le principe est de marquer certaines arrêtes (edge) du
 maillage comme etant des coutures (seam).
 Ces coutures sont visible en rouge sur la capture d'écran suivante.
 Le dépliage se fait ensuite grâce à un algorithme interne de Blender, qui
 va déplier (unwrap) au mieux ces surfaces.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename couture.png
	width 100text%

\end_inset


\end_layout

\begin_layout Standard
Une fois le dépliage terminé, nous avons texturé le modèle.
 Ce texturage s'est fait en 3 étapes.
\end_layout

\begin_layout Enumerate
Nou avons projeté la photo vue de dessus du modèle réel sur le modèle virtuel
 grâce à Blender.
 Cela nous a permis d'obtenir les décorations du dessus du modèle facilement,
 déformé de la bonne façon pour coller à notre dépliage.
\end_layout

\begin_layout Enumerate
Nous avons ensuite completé la texture grâce au logiciel de traitement d'image
 The Gimp.
 Nous avons utilisé notamment l'outil de clonage pour dupliquer la texture
 de polystirène noir partout où c'était necessaire.
\end_layout

\begin_layout Enumerate
Nous avons calculé l'ombrage que le modèle se fait sur lui même (ambient
 occlusion).
 C'est à dire que certaines partie du modèle en cache d'autre, ce qui crée
 des zones plus sombre que les autres.
 Blender permet de projeter sur une texture ces zones d'ombre, que nous
 avons ensuite combiné au reste de la texture.
 Celà permet d'avoir un peu plus de réalisme, pour un coût complètement
 nul au rendu.
\end_layout

\begin_layout Standard
La capture d'écran suivante présente la texture finale avec les différentes
 couches, ainsi que le dépliage du modèle.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename tex_UV.png
	width 100text%

\end_inset


\end_layout

\begin_layout Section
Contenu de la scène
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename scene.png
	scale 50

\end_inset


\end_layout

\begin_layout Standard
La scène finale comporte plusieurs objets:
\end_layout

\begin_layout Itemize
Le modèle du quadricoptère (Quadri)
\end_layout

\begin_layout Itemize
Un niveau basique où évolue le modèle (Level)
\end_layout

\begin_layout Itemize
Une camera
\end_layout

\begin_layout Itemize
Un ensemble d'objets parenté à la camera qui servent à afficher le HUD,
 que nous détaillerons plus loin.
\end_layout

\begin_layout Itemize
Un modèle haute résolution du quadricoptère (Quadri.high), qui n'est pas
 utilisé actuellement.
\end_layout

\begin_layout Itemize
Un modèle ultra-simplifié du quadricoptère (32 points, 30 faces), qui va
 être utilisé comme modèle de collision pour le moteur physique (non actif
 actuellement).
\end_layout

\begin_layout Section
Simulation physique du quadricopère
\end_layout

\begin_layout Subsection
Principe global
\end_layout

\begin_layout Standard
Afin de pouvoir donner son comportement au modèle dans le mode de jeu de
 Blender, il a fallu définir plusieurs types d'objets sur notre modèle de
 quadricoptère.
\end_layout

\begin_layout Itemize
les 
\begin_inset Quotes eld
\end_inset

sensors
\begin_inset Quotes erd
\end_inset

 qui détectent une action sur une entrée et génèrent un évènement.
 Dans notre cas cela correspond aux touches du clavier, ou à un Joystick.
\end_layout

\begin_layout Itemize
les 
\begin_inset Quotes eld
\end_inset

controller
\begin_inset Quotes erd
\end_inset

  qui sont le plus souvent des expressions logiques (OR, NAND...) faisant la
 liaison entre les sensor et les controller.
 Dans notre cas, la complexité du comportement nous a poussé à utiliser
 des script Python en tant que controller.
\end_layout

\begin_layout Itemize
les 
\begin_inset Quotes eld
\end_inset

actuators
\begin_inset Quotes erd
\end_inset

 qui se chargent de modifier le modèle suivant les paramètres du controller.
 Dans notre cas, ils sont au nombre de 4, un pour chaque moteur du quadricoptère.
\end_layout

\begin_layout Standard
Ces différents éléments sont destinés à être reliés entre eux suivant le
 comportement que l'on souhaite définir.
\end_layout

\begin_layout Standard
A noter également que nous avons deux 
\begin_inset Quotes eld
\end_inset

sensors
\begin_inset Quotes erd
\end_inset

 always.
 Le premier est relié au script python et permet un déclenchement périodique
 du script est utilisé dans pour l'utilisation du Joystick puisque celui-ci
 n'envoi aucun élément mais que les valeurs de ces axes/boutons.
 Le deuxième est relié directement aux 
\begin_inset Quotes eld
\end_inset

actuators
\begin_inset Quotes erd
\end_inset

 via un controller and de façon à activer les 
\begin_inset Quotes eld
\end_inset

actuators
\begin_inset Quotes erd
\end_inset

 de façon permanente.
\end_layout

\begin_layout Standard
\begin_inset Graphics
	filename logic_quadri.png
	width 100text%

\end_inset


\end_layout

\begin_layout Subsection
Comportement simple
\end_layout

\begin_layout Standard
Le but du comportement simple est de pouvoir agir via une touche du clavier
 sur un moteur.
\end_layout

\begin_layout Standard
Nous avons donc défini une variable pour chaque force appliquée à chaque
 moteur.
\end_layout

\begin_layout Standard
Ainsi nous avons parties distinctes dans notre code pour gérer ce comportement.
\end_layout

\begin_layout Standard
Une qui détecte une pression sur une 4 touches et qui incrémente la force
 correspondante.
\end_layout

\begin_layout Standard
La deuxième partie consiste à affecter les 4 forces au modèle.
 Il faut préciser qu'avec Blender, toutes les forces s'appliquent, par défaut,
 au centre de gravité de l'objet considéré.
 Pour remedédier à ce problème nous appliquons également à cet endroit du
 script les moments qui sont nécessaires pour 
\begin_inset Quotes eld
\end_inset

déplacer
\begin_inset Quotes erd
\end_inset

 la force au point qui nous intéresse (en loccurence la position où se trouve
 le moteur).
\end_layout

\begin_layout Subsection
Comportement évolué
\end_layout

\begin_layout Standard
Le comportement évolué reprend le comportement précédent mais offre la possibili
té de piloter le quadricoptère.
\end_layout

\begin_layout Standard
En effet, nous avons dans ce cas 8 autres touches pour piloter le quadricoptère.
 Mais dans ce cas, une pression sur une touche aura pour effet de modifier
 plusieurs forces à la fois.
\end_layout

\begin_layout Standard
Ainsi on offre la possibilité à l'utilisateur du décollage, tangage et lacet.
\end_layout

\begin_layout Subsection
Joystick
\end_layout

\begin_layout Standard
Le comportement via Joystick est légèrement différent de celui au clavier.
\end_layout

\begin_layout Standard
En effet, comme précisé précedemment, le Joystick n'envois pas directement
 des évènements mais juste un tableau de 4 valeurs correspondant aux valeurs
 des axes (3 axes de la manette plus l'axe de la molette des gaz).
\end_layout

\begin_layout Standard
On a donc ajouté un sensor always qui permet de lire en continue les valeurs
 envoyés par le joystick.
\end_layout

\begin_layout Standard
Notons également deux points importants de ce comportement.
 Nous avons définie une 
\end_layout

\begin_layout Subsubsection
Zone morte
\end_layout

\begin_layout Standard
Notons également deux points importants de ce comportement.
 Nous avons définie une 
\begin_inset Quotes eld
\end_inset

zone morte
\begin_inset Quotes erd
\end_inset

 , qui permet de rendre le joystick moins sensible aux variations minimum.
 Cette sensibilité peut être modifié via la constante THRESHOLD (il est
 à noté que la position d'un axe va de -32768 à 32767).
\end_layout

\begin_layout Subsubsection
Gestion du pilotage
\end_layout

\begin_layout Standard
Le deuxième ajout est une aide au pilotage.
 Concrètement celle-ci consiste à repositionner le quadricoptère dans sa
 position initiale si l'utilisateur lache le joystick.
\end_layout

\begin_layout Standard
Pour cela on va récupère l'orientation de notre modèle par rapport à l'environne
ment (elle est representée par une matrice 3x3), puis on applique des forces
 opposés à l'orientation actuelle afin de remettre le quadricopètre dans
 une position 
\begin_inset Quotes eld
\end_inset

neutre
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Section
HUD
\end_layout

\begin_layout Subsection
Principe global
\end_layout

\begin_layout Standard
Le HUD (head's up display) que nous avons implémenté est constitué d'un
 indicateur de vitesse et d'un indicateur d'altitude.
 Le principe est relativement simple.
 Pour chaque indicateur, deux plans sont positionné parallèlement à la camera
 et parenté à elle de sorte que si la caméra bouge, les indicateurs suivent.
 Ces plans sont texturés avec les deux textures suivantes:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename /home/michael/Bureau/projet quadricoptère/HUD/fondaltimetre.png
	lyxscale 50
	scale 50
	rotateOrigin center

\end_inset

 
\begin_inset Graphics
	filename /home/michael/Bureau/projet quadricoptère/HUD/aiguille.png
	lyxscale 50
	scale 50
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Les matériaux pour ces deux plans sont un peu particuliers:
\end_layout

\begin_layout Itemize
Activation de la transparence (la texture affecte les canaux color et alpha,
 valeur de alpha par défaut: 0).
\end_layout

\begin_layout Itemize
Matériau en shadeless, c'est à dire pas de calcul d'ombrage ou d'eclairage.
 Seule les couleurs de la texture sont affichés.
\end_layout

\begin_layout Standard
Le centre de l'objet aiguille est placé au niveau de l'axe de rotation de
 l'aiguille, de sorte qu'on ai juste à appliquer une rotation à l'aiguille
 pour fixer la valeur.
 Les afficheurs prennent vie grace à un script python simple que nous allons
 voir dans la partie suivante.
 Le réseau logique utilisé est le suivant:
\end_layout

\begin_layout Standard
\align center
\begin_inset Graphics
	filename logic_HUD.png
	width 100col%
	rotateOrigin center

\end_inset


\end_layout

\begin_layout Standard
Nous avons donc:
\end_layout

\begin_layout Itemize
Un sensor 
\begin_inset Quotes eld
\end_inset

Always
\begin_inset Quotes erd
\end_inset

 qui active le script à interval réguliers
\end_layout

\begin_layout Itemize
Un controller 
\begin_inset Quotes eld
\end_inset

Python
\begin_inset Quotes erd
\end_inset

 avec notre script
\end_layout

\begin_layout Itemize
Un actuator 
\begin_inset Quotes eld
\end_inset

Motion
\begin_inset Quotes erd
\end_inset

 qui ne sert strictement à rien, si ce n'est d'avoir un graph valide (sinon
 le script ne se déclencherai pas).
\end_layout

\begin_layout Subsection
Script python
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "breaklines=true,language=Python,numbers=left"
inline false
status open

\begin_layout Plain Layout

import bge 
\end_layout

\begin_layout Plain Layout

from mathutils import Matrix
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# récupère la scène et la liste des objets
\end_layout

\begin_layout Plain Layout

scene = bge.logic.getCurrentScene()
\end_layout

\begin_layout Plain Layout

List = scene.objects
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# récupère le controleur, puis l'objet aiguille qui détient ce controleur
\end_layout

\begin_layout Plain Layout

cont = bge.logic.getCurrentController()
\end_layout

\begin_layout Plain Layout

aiguille = cont.owner
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# récupère l'objet quadricoptère dans la liste des objets de la scène, puis
 sa vitesse
\end_layout

\begin_layout Plain Layout

value = List['Quadri'].worldLinearVelocity.length
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

# affecte une matrice de rotation à l'objet aiguille, calculée d'après la
 valeur à afficher
\end_layout

\begin_layout Plain Layout

aiguille.localOrientation = Matrix.Rotation(-value / 10.0, 4, 'Z').to_3x3()
\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\end_body
\end_document
